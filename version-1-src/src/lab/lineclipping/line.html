<!DOCTYPE HTML>
<html>
<head>
  <script type="text/javascript" src="canvasjs.min.js"></script>
  <script type="text/javascript">
      
      var clipwindow = function(){
          this.chart =null;
          this.xmin = 0;
          this.xmax = 0;
          this.ymin = 0;
          this.ymax = 0;
          this.rowmindps = [];
          this.rowmaxdps = [];
          this.colmindps = [];
          this.colmaxdps = [];
          this.linedps =[];
          this.clipdatadps = [];
          this.cliplinedps = [];
          this.finalclipdps = [];
          this.initializechart = function (){
              this.chart = new CanvasJS.Chart("chartContainer", {
              axisX:{
                       minimum: 0,
                       maximum: 400
                  
                     },   
              axisY:{
                       minimum: 0,
                       maximum: 400,
                       gridThickness : 0
                    },
              data:[{
                      type: "line",
                      color: "DarkSlateBlue",
                      indexLabel: "ymin : {y}",
                      indexLabelOrientation: "vertical",
                      indexLabelFontSize: 12,
                      dataPoints: this.rowmindps
                    },
                    {
                      type: "line",
                      color: "DarkSlateBlue",
                      indexLabel: "ymax: {y}",
                      indexLabelOrientation: "vertical",
                      indexLabelFontSize: 12,    
                      dataPoints: this.rowmaxdps
                    },
                    {
                      type: "line",
                      color: "DarkSlateBlue",                            
                      indexLabel: "xmin: {x}",
                      indexLabelFontSize: 12,
                      dataPoints: this.colmindps
                    },
                    {
                      type: "line",
                      color: "DarkSlateBlue",
                      indexLabel: "xmax: {x}",
                      indexLabelFontSize: 12,  
                      dataPoints: this.colmaxdps
                    },
                    {
                      type: "line",
                      color: "DarkOrange",
                      indexLabel: "({x},{y})",
                      indexLabelFontSize: 12,    
                      dataPoints: this.linedps
                    },
                    {
                      type: "line",
                      indexLabel: "({x},{y})",
                      indexLabelFontSize: 12,     
                      dataPoints: this.clipdatadps
                    },
                    {
                      type: "line",
                      indexLabel: "({x},{y})",
                      color: "ForestGreen", 
                      indexLabelFontSize: 12,     
                      dataPoints: this.finalclipdps
                    }
                   ]
             });     
               
      }
       this.drawcanvas= function(){      
            if((this.rowmaxdps.length & this.rowmindps.length & this.colmaxdps.length & this.colmindps.length) !=0)  {
                console.log('free dps data 1');
                this.rowmindps.length =0;
                this.rowmaxdps.length =0;
                this.colmindps.length =0;
                this.colmaxdps.length =0;
            }
            this.colmindps.push({x:this.xmin,y:0},{x:this.xmin,y:400});
            this.colmaxdps.push({x:this.xmax,y:0},{x:this.xmax,y:400});
            this.rowmindps.push({x:0,y:this.ymin},{x:400,y:this.ymin});
            this.rowmaxdps.push({x:0,y:this.ymax},{x:400,y:this.ymax});  
            
                this.linedps.length = 0;
                this.clipdatadps.length = 0;
                this.cliplinedps.length = 0;
                this.finalclipdps.length = 0;
            
           this.chart.render();     
        }      
      this.defaultwindow = function(){
          document.getElementById("xmin").value = 100;
          document.getElementById("ymin").value = 100;
          document.getElementById("xmax").value = 300;
          document.getElementById("ymax").value = 300;
          this.xmin = parseInt(document.getElementById("xmin").value);
          this.xmax = parseInt(document.getElementById("xmax").value);
          this.ymin = parseInt(document.getElementById("ymin").value);
          this.ymax = parseInt(document.getElementById("ymax").value);
          
          
          this.initializechart();
          this.drawcanvas();
      }
      
      this.updatewindow = function(){
                 console.log('update window');
                 if(document.getElementById("xmin").value <= document.getElementById("xmax").value && document.getElementById("ymin").value <= document.getElementById("ymax").value)
                  {
                      
                      this.xmin = parseInt(document.getElementById("xmin").value);
                      this.xmax = parseInt(document.getElementById("xmax").value);
                      this.ymin = parseInt(document.getElementById("ymin").value);
                      this.ymax = parseInt(document.getElementById("ymax").value);
                      console.log(this.xmin,this.ymin,this.xmax,this.ymax);
                      this.drawcanvas();
                      //location.reload();
                      return true;
                  }
               return false;
      }
      
      };
      var Experiment = function(objwindow,start,end){
            
             this.startOpcode = null;
             this.endOpcode = null;
             this.resultstart = [];
             this.resultend = [];
             this.slope = 0;
             this.sconst = 0;
             this.intersections_list = [];
             this.set_outcode =function(point)
			 {
				outcode = '';

				x = point[0];
				y = point[1];

				if(y > objwindow.ymax)
					outcode = outcode + '1';
				else
					outcode = outcode + '0';

				if(y < objwindow.ymin)
					outcode = outcode + '1';
				else
					outcode = outcode + '0';

				if(x > objwindow.xmax)
					outcode = outcode + '1';
				else
					outcode = outcode + '0';

				if(x < objwindow.xmin)
					outcode = outcode + '1';
				else
					outcode = outcode + '0';

				return outcode;
			 }
             this.clippingRequired=function(){
                if(this.startOpcode == '0000' && this.endOpcode == '0000' )
                   {
                       objwindow.cliplinedps.length=0;
                       objwindow.cliplinedps.push({x:parseInt(this.resultstart[0]),y:parseInt(this.resultstart[1])},{x:parseInt(this.resultend[0]),y:parseInt(this.resultend[1])});
                       return false;
                   }
                else if(((parseInt(this.startOpcode, 2) | parseInt(this.endOpcode,2)) != 15 ) &(parseInt(this.startOpcode, 2) & parseInt(this.endOpcode,2)) !=0 )
                    {
                        objwindow.clipdatadps.length =0;
                        objwindow.clipdatadps.push({x:parseInt(this.resultstart[0]),y:parseInt(this.resultstart[1])},{x:parseInt(this.resultend[0]),y:parseInt(this.resultend[1])});
                        return false;
                    }
                else
                    return true;
                
            }
            this.addintersectiondata = function(start,end)
            {
                this.intersections_list.push({x:parseInt(start[0]),y:parseInt(start[1])},{x:parseInt(end[0]),y:parseInt(end[1])});
            }
            this.dolineclipping = function(inpoint,pointopcode){
                
                var intersectcord = [];
                var point = inpoint;
               // this.intersections_list.push([pointopcode,point]);
                console.log("first"+this.intersections_list);
                while(parseInt(pointopcode,2) != 0)
                    {
                       
                         if(pointopcode.charAt(0) == '1')
                               {
                                console.log(parseInt(pointopcode,2));   
                                intersectcord[0] = Math.ceil((objwindow.ymax - this.sconst)/this.slope);
					            intersectcord[1] = objwindow.ymax;
                                //this.intersections_list.push([{x:parse.int(point[0]),y:point[1]},{x:intersectcord[0],y:intersectcord[1]}]);
                                this.addintersectiondata(point,intersectcord);
                                console.log("second"+this.intersections_list);
                                
                                point = intersectcord;
                                console.log("ymax");
                                pointopcode = this.set_outcode(point);   
                               }
                         if(pointopcode.charAt(1) == '1')
                             {
                                intersectcord[0] = Math.ceil((objwindow.ymin - this.sconst)/this.slope);
					            intersectcord[1] = objwindow.ymin;
                                this.addintersectiondata(point,intersectcord);
                                console.log("third"+this.intersections_list);
                                point = intersectcord;
                                 console.log("ymin");
                                pointopcode = this.set_outcode(point);  
                             }
                        if(pointopcode.charAt(2) == '1')
                            {
                                intersectcord[0] = objwindow.xmax;
					            intersectcord[1] = Math.ceil((this.slope * objwindow.xmax + this.sconst));
                                this.addintersectiondata(point,intersectcord);

                                console.log("fourth"+this.intersections_list);
                                point = intersectcord;
                                console.log("xmax");
                                pointopcode = this.set_outcode(point); 
                            }
                        if(pointopcode.charAt(3) == '1')
                            {
                                intersectcord[0] = objwindow.xmin;
					            intersectcord[1] = Math.ceil((this.slope * objwindow.xmin + this.sconst));
                                this.addintersectiondata(point,intersectcord);
                                console.log("fifth"+this.intersections_list);
                                point = intersectcord;
                                console.log("xmin");
                                pointopcode = this.set_outcode(point); 
                            }
                        
                    }
                            
                      return  point;
                              
            }
            this.startExperiment = function(){
                this.startOpcode = this.set_outcode(start);
                this.endOpcode = this.set_outcode(end);
                
                this.resultstart = start;
                this.resultend = end;
                this.intersections_list.length =0;
                objwindow.linedps.push({x:parseInt(start[0]),y:parseInt(start[1])},{x:parseInt(end[0]),y:parseInt(end[1])});
                objwindow.chart.render();
                console.log("drawnline");
                if(this.clippingRequired())
                    {
                         this.slope = (end[1]-start[1])/(end[0]-start[0]);

				         //find constant 'c' by substituting one of the end points for x and y
				         this.sconst = start[1] - this.slope*start[0];
                    
                         console.log("slope :"+ this.slope);
                         if(this.startOpcode == '0000')
                          {
                            this.resultend = this.dolineclipping(end,this.endOpcode);
                             objwindow.cliplinedps.length =0;  
                              objwindow.cliplinedps.push({x:parseInt(start[0]),y:parseInt(start[1])},{x:parseInt(this.resultend[0]),y:parseInt(this.resultend[1])}); console.log("this.startOpcode is 0000");    
                          }
                          else if(this.endOpcode == '0000')
                          {
                            this.resultstart = this.dolineclipping(start,this.startOpcode);
                             objwindow.cliplinedps.length =0;    
                            objwindow.cliplinedps.push({x:parseInt(this.resultstart[0]),y:this.resultstart[1]},{x:parseInt(end[0]),y:parseInt(end[1])});   
                            console.log("this.endOpcode is 0000");       
                          }
                          else
                          {
                            console.log("both are non 0000");  
                            this.resultstart = this.dolineclipping(start,this.startOpcode);
                            this.resultend = this.dolineclipping(end,this.endOpcode);
                            objwindow.cliplinedps.length =0;  
                            objwindow.cliplinedps.push({x:this.resultstart[0],y:this.resultstart[1]},{x:this.resultend[0],y:this.resultend[1]});  
                         }
                    }
             console.log(this.intersections_list);
            //  objwindow.cliplinedps.push({x:this.resultstart[0],y:this.resultstart[1]},{x:this.resultend[0],y:this.resultend[1]});
            //  objwindow.chart.render();
            }
      };
      var Iterator = function(items) {
         this.index = 0;
         this.items = items;
         this.first = function() {
            this.reset();
            return this.next();
          },
         this.next = function() {
            return this.items[this.index++];
          },
         this.hasNext= function() {
            return this.index <= this.items.length;
          },
         this.reset= function() {
            this.index = 0;  
         },
         this.hasPrevious =function(){
            if(index == 0) return false;
             else
               return true;         
         }     
         this.previous = function(){
             this.index--;
             return this.items[index];
         }
         };
      window.onload = function () {
                  
          
      }
  </script>
</head>
 
<body>
  <div id="chartContainer" style="height: 500px; width: 50%;"></div>
  <div id="inputinformation">
  <br>
  <p id="text_one">Co-ordinates of bottom left corner</p>             
  <input id="xmin" type="number" value = 100 >    
  <input id="ymin" type="number" value = 100 >
  <br>
  <p id="text_two"> Co-ordinates of upper right  corner</p>
  <input id="xmax" type="number" value = 300 >    
  <input id="ymax" type="number" value = 300 >  
  <br>
  </div>         
  <br>
  <button id="Enter" style="width:150px;">Enter</button>       
  <button id="Experiementval" style="display:none;">Start Experiment</button>
  <button id="previous" style="display:none;">previous</button>    
  <button id="next" style="display:none">next</button>   
  <br>    
  <br>    
  <button id="experiment" style="width:150px;">Start Experiment with default values</button>
  <button id="back" style="display:none;">back</button>    
  <script>
      var objwindow = null;
      objwindow = new clipwindow();
      objwindow.defaultwindow();
      var lineiterator = null;
      document.getElementById("experiment").addEventListener("click", function(){
              start = [10, 350];
              end = [350, 10];
              var objExperiment = new Experiment(objwindow,start,end);
              objExperiment.startExperiment();
              document.getElementById("experiment").style.display = "none";
              document.getElementById("previous").style.display = "block";
              document.getElementById("previous").style.display = "inline-block";
              document.getElementById("next").style.display = "block";
              document.getElementById("next").style.display = "inline-block";
              document.getElementById("inputinformation").style.display = "none";
              document.getElementById("back").style.display = "block";
              document.getElementById("back").style.display = "inline-block";
              document.getElementById("Enter").style.display = "none"; 
               console.log(objExperiment.intersections_list);
             // lineiterator = new Iterator(objExperiment.intersections_list);
               if(objExperiment.intersections_list.length > 0)
                  {
                      objwindow.finalclipdps.length = 0;
                      objwindow.finalclipdps.push(objwindow.cliplinedps.pop());
                      
                      
                  }
                else{
                    if(lineiterator != null)lineiterator = null;
                    lineiterator = new Iterator(objExperiment.intersections_list);
                   }
         });
      
       
      document.getElementById("Enter").addEventListener("click",function(){
           if(objwindow.updatewindow())
               {  
                   document.getElementById("Enter").style.display = "none"; 
                   document.getElementById("Experiementval").style.display = "block";
                   document.getElementById("Experiementval").style.display = "inline-block";
                   
                   document.getElementById("experiment").style.display = "none";
                   document.getElementById("back").style.display = "block";
                   document.getElementById("back").style.display = "inline-block";
                   document.getElementById('text_one').innerHTML = "Enter cordinates (x,y) of one end point of line";
                   document.getElementById('text_two').innerHTML = "Enter cordinates (x,y) of other end point of line"; 
                   document.getElementById("xmin").value = 10;
                   document.getElementById("xmax").value = 350;
                   document.getElementById("ymin").value = 350;
                   document.getElementById("ymax").value = 10;
                   
               
               }           
                
        });
        document.getElementById("back").addEventListener("click",function(){
            objwindow.defaultwindow();
            document.getElementById("Experiementval").style.display = "none";
            document.getElementById("Enter").style.display = "block";
            document.getElementById("Enter").style.display = "inline-block";
            
            document.getElementById("back").style.display = "none";
            document.getElementById("experiment").style.display = "block";
            document.getElementById("experiment").style.display = "inline-block";
            document.getElementById('text_one').innerHTML = "Co-ordinates of bottom left corner";
            document.getElementById('text_two').innerHTML = "Co-ordinates of upper right corner";
            document.getElementById("inputinformation").style.display ="block";
            document.getElementById("previous").style.display = "none";
            document.getElementById("next").style.display = "none";
            
        });
      
      document.getElementById("Experiementval").addEventListener("click",function(){
              start = [document.getElementById("xmin").value, document.getElementById("ymin").value];
              end = [document.getElementById("xmax").value, document.getElementById("ymax").value];
              var objExperiment = new Experiment(objwindow,start,end);
              objExperiment.startExperiment();
              document.getElementById("Experiementval").style.display = "none";
              document.getElementById("previous").style.display = "block";
              document.getElementById("previous").style.display = "inline-block";
              document.getElementById("next").style.display = "block";
              document.getElementById("next").style.display = "inline-block";
              document.getElementById("inputinformation").style.display = "none";
              
              console.log(objExperiment.intersections_list);
              if(objExperiment.intersections_list.length == 0)
                  {
                      if(objwindow.cliplinedps.length > 0)
                          {
                            objwindow.finalclipdps.length = 0;
                            objwindow.finalclipdps.push(objwindow.cliplinedps.pop());
                          }
                      objwindow.chart.render();
                  }
                else{
                    if(lineiterator != null)lineiterator = null;
                    lineiterator = new Iterator(objExperiment.intersections_list);
                   }
              
      });
      document.getElementById("previous").addEventListener("click",function(){
          if(lineiterator.items != null)
          {
            if(objwindow.clipdatadps.length >= 1)  
            {
                objwindow.clipdatadps.pop();                
            }
             objwindow.chart.render();    
          }
         
      });
      document.getElementById("next").addEventListener("click",function(){
         if(lineiterator.items != null)
             {
              
                if(lineiterator.hasNext())
                      objwindow.clipdatadps.push(lineiterator.next());
                else
                     {
                      objwindow.clipdatadps.length=0;
                      objwindow.clipdatadps.push(lineiterator.first());
                     }
                 objwindow.chart.render();
              }
             
                 
          
          
          
      });
    </script>
    
</body>
</html>